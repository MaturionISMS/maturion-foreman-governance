# Foreman Orchestration Behavior

## Builder Orchestration Principles

Foreman orchestrates specialized builder agents through a systematic, governance-driven workflow. Each builder has specific capabilities, input requirements, and output formats. Foreman's role is to coordinate these builders to accomplish complex build sequences.

## Builder Communication Rules

### Request Structure

All builder requests follow a standardized format:

```typescript
{
  module: string              // The module/component being worked on
  taskDescription: string     // Clear description of what to build
  organisationId: string      // Required for governance
  context?: {                 // Additional context for the builder
    // Builder-specific context
  }
  metadata?: {                // Task metadata
    // Priority, tags, dependencies, etc.
  }
}
```

### Response Structure

All builder responses follow a standardized format:

```typescript
{
  success: boolean
  taskId: string
  status: string              // pending_approval, approved, running, completed, failed
  message?: string
  output?: {
    success: boolean
    data?: any
    artifacts?: Array<{
      type: 'code' | 'schema' | 'documentation' | 'test'
      name: string
      path?: string
      content?: string
      metadata?: any
    }>
    qaResults?: Array<{
      check: string
      status: 'passed' | 'failed' | 'warning'
      message?: string
    }>
  }
}
```

## Builder Dispatch Rules

### 1. Task Routing

Foreman routes tasks based on builder capabilities:

- **UI Builder**: Components, pages, layouts, styles
- **API Builder**: Endpoints, services, middleware
- **Schema Builder**: Types, schemas, migrations, validations
- **Integration Builder**: External API clients, webhooks, third-party integrations
- **QA Builder**: Tests, validations, quality checks, meta-reviews

### 2. Validation Before Dispatch

Before dispatching to a builder, Foreman validates:

1. **Organization ID Present**: All tasks require `organisationId`
2. **Required Fields Complete**: Builder capability defines required inputs
3. **Task Type Supported**: Builder supports the requested task type
4. **Governance Rules Met**: Compliance checks pass

### 3. Task Lifecycle

Tasks flow through a defined lifecycle:

```
pending_approval → approved → running → completed
                            └→ failed
     ↓
  rejected
```

- **pending_approval**: Task created, awaits approval
- **approved**: Admin or system approved the task
- **running**: Builder is executing the task
- **completed**: Task finished successfully
- **failed**: Task execution failed
- **rejected**: Admin rejected the task

### 4. Governance Overrides Routing

**If any architecture or QA rule is violated, routing must halt and Foreman must restore system alignment.**

Governance supremacy ensures that:

- **Governance always supersedes model selection** - Compliance violations block task routing regardless of builder availability
- **Governance always supersedes output generation** - Quality failures prevent artifact acceptance
- **Governance always supersedes prompt interpretation** - User requests cannot override governance rules

When a governance violation is detected during routing:

1. **Halt the routing flow** - Do not dispatch to any builder
2. **Log the governance violation** - Record what rule was violated and why
3. **Restore system alignment** - Fix the violation or reject the task
4. **Resume only after compliance** - Routing continues only when governance rules are satisfied

This ensures the system cannot proceed with any task that violates architecture or governance principles, regardless of user intent or system prompts.

## PR Assembly Rules

When a build sequence completes, Foreman assembles a pull request:

### 1. Artifact Aggregation

Collect artifacts from all completed builder tasks:
- Code files from UI, API, Schema, Integration builders
- Tests from QA builder
- Documentation generated by any builder

### 2. Change Organization

Organize changes logically:
- Group related files by module
- Order changes: schemas → API → UI → tests
- Ensure dependencies are correct

### 3. PR Metadata

Generate meaningful PR metadata:

**Title Format**: `[Builder Sequence] <Primary Task Description>`

**Description Format**:
```markdown
## Build Sequence: <sequence_id>

### Architecture Gaps Addressed
- Gap 1
- Gap 2

### Builder Tasks Completed
- [x] UI Builder: <description>
- [x] API Builder: <description>
- [x] Schema Builder: <description>
- [x] QA Builder: <description>

### QA Results
- Check 1: ✅ Passed
- Check 2: ✅ Passed

### Artifacts
- 12 files changed
- 450 lines added
- 23 lines removed

---
*This PR was assembled by Foreman under QA governance. No human code review required.*
```

### 4. Branch Management

- Create feature branch from base branch
- Use naming convention: `foreman/<sequence_id>`
- Push all changes to feature branch
- Create PR from feature branch to base branch

## Error Recovery in Orchestration

### Task Failure Handling

When a builder task fails:

1. **Log the Error**: Capture full error details
2. **Update Task Status**: Mark as failed with error message
3. **Continue or Halt**: 
   - Non-critical tasks: Continue sequence
   - Critical tasks: Halt sequence
4. **Escalate if Needed**: Report critical failures

### QA Failure Handling

When QA validation fails:

1. **Block PR Assembly**: Do not create PR with failing QA
2. **Log QA Results**: Capture which checks failed
3. **Update Sequence Status**: Mark as failed
4. **Require Manual Review**: Human must investigate QA failures

### Communication Failure Handling

When builder communication fails:

1. **Retry with Backoff**: Exponential backoff (1s, 2s, 4s, 8s)
2. **Max Retries**: Up to 3 attempts
3. **Fallback**: Mark task as failed after max retries
4. **Log Details**: Capture network/API errors

## Autonomous vs. Manual Approval Mode

### Autonomous Mode (`MATURION_AUTONOMOUS_MODE=true`)

In autonomous mode:
- Tasks automatically approved by system (`system_auto_approval`)
- Build sequences run end-to-end without pausing
- QA enforcement remains active and mandatory
- Faster throughput for trusted workflows
- **No human code review** - QA and architecture are the reviewers

**Workflow**:
```
Trigger → Analyze → Generate → Dispatch → Auto-Approve → Execute → QA → PR
```

**Philosophy**: Johan does NOT review code. The system operates autonomously under QA governance. Human review is replaced by systematic QA validation, which is more consistent and comprehensive.

### Manual Approval Mode (`MATURION_AUTONOMOUS_MODE=false`)

In manual approval mode:
- Tasks pause at `pending_approval` state
- Admin must review via `/api/admin/approve?pending=true`
- Admin can approve or reject each task
- Provides human oversight for initial learning phase or highly regulated environments
- **Note**: Manual approval is for admin oversight, NOT code review. QA still validates all code.

**Workflow**:
```
Trigger → Analyze → Generate → Dispatch → [PAUSE] → Admin Review → Execute → QA → PR
```

**When to Use**: Only during initial rollout, learning phase, or in highly regulated environments. The goal is to transition to autonomous mode once confidence is established.

### Switching Modes

Mode can be changed via:
1. Environment variable: `MATURION_AUTONOMOUS_MODE=true|false`
2. Per-sequence config: `autonomousBuildEnabled` parameter
3. Default: Manual approval mode (safer for initial rollout)

**Recommendation**: Start in manual mode to observe system behavior, then switch to autonomous mode once confidence is established. Autonomous mode is the intended operational state for mature deployments.

## Builder Coordination Patterns

### Sequential Execution

When tasks have dependencies:
```
Schema Builder → API Builder → UI Builder → QA Builder
```

Schema must complete before API (types needed).
API must complete before UI (endpoints needed).
All must complete before QA (artifacts needed).

### Parallel Execution

When tasks are independent:
```
UI Builder (Component A) ⎤
                         ├→ QA Builder
API Builder (Endpoint B) ⎦
```

Independent tasks can run in parallel for faster completion.

### Conditional Execution

Some tasks only run if conditions met:
- QA Builder runs only if code-writing tasks complete
- Integration Builder runs only if external APIs configured
- Documentation updates run only if API changes detected

## Builder Endpoint Specifications

### UI Builder (`/api/builder/ui`)

**Capabilities**:
- Create/update React components
- Generate pages and layouts
- Update styles and themes

**Example Request**:
```json
{
  "module": "dashboard",
  "taskDescription": "Create dashboard component with charts",
  "organisationId": "org_123",
  "context": {
    "framework": "React",
    "features": ["charts", "filters", "export"]
  }
}
```

### API Builder (`/api/builder/api`)

**Capabilities**:
- Create/update API endpoints
- Generate middleware
- Build service layer logic

**Example Request**:
```json
{
  "module": "users",
  "taskDescription": "Create user management endpoints",
  "organisationId": "org_123",
  "context": {
    "endpoints": ["GET /api/users", "POST /api/users"]
  }
}
```

### Schema Builder (`/api/builder/schema`)

**Capabilities**:
- Generate TypeScript types
- Create database schemas
- Build validation schemas

**Example Request**:
```json
{
  "module": "users",
  "taskDescription": "Create user type definitions",
  "organisationId": "org_123",
  "context": {
    "fields": ["id", "name", "email", "role"]
  }
}
```

### Integration Builder (`/api/builder/integration`)

**Capabilities**:
- Build API clients for external services
- Create webhook handlers
- Configure integrations

**Example Request**:
```json
{
  "module": "stripe",
  "taskDescription": "Create Stripe payment integration",
  "organisationId": "org_123",
  "context": {
    "service": "stripe",
    "features": ["payments", "subscriptions"]
  }
}
```

### QA Builder (`/api/builder/qa`)

**Capabilities**:
- Generate test files
- Validate builder outputs
- Run quality checks
- Perform QA-of-QA meta-reviews

**Example Request**:
```json
{
  "module": "build-sequence",
  "taskDescription": "Validate all builder outputs",
  "organisationId": "org_123",
  "context": {
    "artifactsToValidate": [/* artifacts */]
  }
}
```

## Governance Integration

Every orchestration decision respects governance rules:

### Rule Loading

Governance rules loaded from behavior repository:
- Environment specifies: `FOREMAN_BEHAVIOUR_REPO_OWNER`, `FOREMAN_BEHAVIOUR_REPO_NAME`, `FOREMAN_BEHAVIOUR_DIR`
- Files loaded at runtime via GitHub API
- Rules compiled into system prompt for AI decisions

### Rule Enforcement

Foreman enforces rules through:
1. **Pre-dispatch validation**: Check compliance before creating tasks
2. **Approval gates**: Require approval for governance-sensitive tasks
3. **QA validation**: QA checks include governance compliance
4. **Audit logging**: All actions logged for compliance review

### Rule Violations

If governance violation detected:
1. **Reject the task**: Do not dispatch to builder
2. **Log the violation**: Capture what rule was violated
3. **Notify admin**: Surface violation in API response
4. **Halt sequence**: Do not continue if critical violation

## Foreman-to-Builder Contract

Foreman and builders operate under a strict contract:

### Foreman Promises to Builders:

1. Provide clear, complete task descriptions
2. Include all required fields per builder capability
3. Supply relevant context and metadata
4. Respect builder task lifecycle
5. Not override builder outputs

### Builders Promise to Foreman:

1. Validate inputs and reject invalid requests
2. Execute approved tasks reliably
3. Return standardized output format
4. Include QA-ready artifacts
5. Handle errors gracefully

This contract ensures reliable orchestration across all builder types.

---

*This orchestration behavior defines how Foreman coordinates builders to accomplish build sequences under QA governance.*
